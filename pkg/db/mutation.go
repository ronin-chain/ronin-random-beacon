// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/ronin-chain/ronin-random-beacon/pkg/db/chaininfo"
	"github.com/ronin-chain/ronin-random-beacon/pkg/db/predicate"
	"github.com/ronin-chain/ronin-random-beacon/pkg/db/randomrequest"
	"github.com/ronin-chain/ronin-random-beacon/pkg/db/task"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeChainInfo     = "ChainInfo"
	TypeRandomRequest = "RandomRequest"
	TypeTask          = "Task"
)

// ChainInfoMutation represents an operation that mutates the ChainInfo nodes in the graph.
type ChainInfoMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	processed_block    *uint64
	addprocessed_block *int64
	finalized_block    *uint64
	addfinalized_block *int64
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ChainInfo, error)
	predicates         []predicate.ChainInfo
}

var _ ent.Mutation = (*ChainInfoMutation)(nil)

// chaininfoOption allows management of the mutation configuration using functional options.
type chaininfoOption func(*ChainInfoMutation)

// newChainInfoMutation creates new mutation for the ChainInfo entity.
func newChainInfoMutation(c config, op Op, opts ...chaininfoOption) *ChainInfoMutation {
	m := &ChainInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeChainInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChainInfoID sets the ID field of the mutation.
func withChainInfoID(id string) chaininfoOption {
	return func(m *ChainInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *ChainInfo
		)
		m.oldValue = func(ctx context.Context) (*ChainInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChainInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChainInfo sets the old ChainInfo of the mutation.
func withChainInfo(node *ChainInfo) chaininfoOption {
	return func(m *ChainInfoMutation) {
		m.oldValue = func(context.Context) (*ChainInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChainInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChainInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChainInfo entities.
func (m *ChainInfoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChainInfoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChainInfoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChainInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProcessedBlock sets the "processed_block" field.
func (m *ChainInfoMutation) SetProcessedBlock(u uint64) {
	m.processed_block = &u
	m.addprocessed_block = nil
}

// ProcessedBlock returns the value of the "processed_block" field in the mutation.
func (m *ChainInfoMutation) ProcessedBlock() (r uint64, exists bool) {
	v := m.processed_block
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessedBlock returns the old "processed_block" field's value of the ChainInfo entity.
// If the ChainInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainInfoMutation) OldProcessedBlock(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessedBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessedBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessedBlock: %w", err)
	}
	return oldValue.ProcessedBlock, nil
}

// AddProcessedBlock adds u to the "processed_block" field.
func (m *ChainInfoMutation) AddProcessedBlock(u int64) {
	if m.addprocessed_block != nil {
		*m.addprocessed_block += u
	} else {
		m.addprocessed_block = &u
	}
}

// AddedProcessedBlock returns the value that was added to the "processed_block" field in this mutation.
func (m *ChainInfoMutation) AddedProcessedBlock() (r int64, exists bool) {
	v := m.addprocessed_block
	if v == nil {
		return
	}
	return *v, true
}

// ResetProcessedBlock resets all changes to the "processed_block" field.
func (m *ChainInfoMutation) ResetProcessedBlock() {
	m.processed_block = nil
	m.addprocessed_block = nil
}

// SetFinalizedBlock sets the "finalized_block" field.
func (m *ChainInfoMutation) SetFinalizedBlock(u uint64) {
	m.finalized_block = &u
	m.addfinalized_block = nil
}

// FinalizedBlock returns the value of the "finalized_block" field in the mutation.
func (m *ChainInfoMutation) FinalizedBlock() (r uint64, exists bool) {
	v := m.finalized_block
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalizedBlock returns the old "finalized_block" field's value of the ChainInfo entity.
// If the ChainInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChainInfoMutation) OldFinalizedBlock(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalizedBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalizedBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalizedBlock: %w", err)
	}
	return oldValue.FinalizedBlock, nil
}

// AddFinalizedBlock adds u to the "finalized_block" field.
func (m *ChainInfoMutation) AddFinalizedBlock(u int64) {
	if m.addfinalized_block != nil {
		*m.addfinalized_block += u
	} else {
		m.addfinalized_block = &u
	}
}

// AddedFinalizedBlock returns the value that was added to the "finalized_block" field in this mutation.
func (m *ChainInfoMutation) AddedFinalizedBlock() (r int64, exists bool) {
	v := m.addfinalized_block
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinalizedBlock resets all changes to the "finalized_block" field.
func (m *ChainInfoMutation) ResetFinalizedBlock() {
	m.finalized_block = nil
	m.addfinalized_block = nil
}

// Where appends a list predicates to the ChainInfoMutation builder.
func (m *ChainInfoMutation) Where(ps ...predicate.ChainInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChainInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChainInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChainInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChainInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChainInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChainInfo).
func (m *ChainInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChainInfoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.processed_block != nil {
		fields = append(fields, chaininfo.FieldProcessedBlock)
	}
	if m.finalized_block != nil {
		fields = append(fields, chaininfo.FieldFinalizedBlock)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChainInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chaininfo.FieldProcessedBlock:
		return m.ProcessedBlock()
	case chaininfo.FieldFinalizedBlock:
		return m.FinalizedBlock()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChainInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chaininfo.FieldProcessedBlock:
		return m.OldProcessedBlock(ctx)
	case chaininfo.FieldFinalizedBlock:
		return m.OldFinalizedBlock(ctx)
	}
	return nil, fmt.Errorf("unknown ChainInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chaininfo.FieldProcessedBlock:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessedBlock(v)
		return nil
	case chaininfo.FieldFinalizedBlock:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalizedBlock(v)
		return nil
	}
	return fmt.Errorf("unknown ChainInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChainInfoMutation) AddedFields() []string {
	var fields []string
	if m.addprocessed_block != nil {
		fields = append(fields, chaininfo.FieldProcessedBlock)
	}
	if m.addfinalized_block != nil {
		fields = append(fields, chaininfo.FieldFinalizedBlock)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChainInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chaininfo.FieldProcessedBlock:
		return m.AddedProcessedBlock()
	case chaininfo.FieldFinalizedBlock:
		return m.AddedFinalizedBlock()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChainInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chaininfo.FieldProcessedBlock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProcessedBlock(v)
		return nil
	case chaininfo.FieldFinalizedBlock:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinalizedBlock(v)
		return nil
	}
	return fmt.Errorf("unknown ChainInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChainInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChainInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChainInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChainInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChainInfoMutation) ResetField(name string) error {
	switch name {
	case chaininfo.FieldProcessedBlock:
		m.ResetProcessedBlock()
		return nil
	case chaininfo.FieldFinalizedBlock:
		m.ResetFinalizedBlock()
		return nil
	}
	return fmt.Errorf("unknown ChainInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChainInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChainInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChainInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChainInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChainInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChainInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChainInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ChainInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChainInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ChainInfo edge %s", name)
}

// RandomRequestMutation represents an operation that mutates the RandomRequest nodes in the graph.
type RandomRequestMutation struct {
	config
	op                Op
	typ               string
	id                *string
	blockNumber       *uint64
	addblockNumber    *int64
	logIndex          *uint
	addlogIndex       *int
	raw               *string
	period            *uint64
	addperiod         *int64
	previousBeacon    *uint64
	addpreviousBeacon *int64
	clearedFields     map[string]struct{}
	task              *int
	clearedtask       bool
	done              bool
	oldValue          func(context.Context) (*RandomRequest, error)
	predicates        []predicate.RandomRequest
}

var _ ent.Mutation = (*RandomRequestMutation)(nil)

// randomrequestOption allows management of the mutation configuration using functional options.
type randomrequestOption func(*RandomRequestMutation)

// newRandomRequestMutation creates new mutation for the RandomRequest entity.
func newRandomRequestMutation(c config, op Op, opts ...randomrequestOption) *RandomRequestMutation {
	m := &RandomRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRandomRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRandomRequestID sets the ID field of the mutation.
func withRandomRequestID(id string) randomrequestOption {
	return func(m *RandomRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *RandomRequest
		)
		m.oldValue = func(ctx context.Context) (*RandomRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RandomRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRandomRequest sets the old RandomRequest of the mutation.
func withRandomRequest(node *RandomRequest) randomrequestOption {
	return func(m *RandomRequestMutation) {
		m.oldValue = func(context.Context) (*RandomRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RandomRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RandomRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RandomRequest entities.
func (m *RandomRequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RandomRequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RandomRequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RandomRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBlockNumber sets the "blockNumber" field.
func (m *RandomRequestMutation) SetBlockNumber(u uint64) {
	m.blockNumber = &u
	m.addblockNumber = nil
}

// BlockNumber returns the value of the "blockNumber" field in the mutation.
func (m *RandomRequestMutation) BlockNumber() (r uint64, exists bool) {
	v := m.blockNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "blockNumber" field's value of the RandomRequest entity.
// If the RandomRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RandomRequestMutation) OldBlockNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// AddBlockNumber adds u to the "blockNumber" field.
func (m *RandomRequestMutation) AddBlockNumber(u int64) {
	if m.addblockNumber != nil {
		*m.addblockNumber += u
	} else {
		m.addblockNumber = &u
	}
}

// AddedBlockNumber returns the value that was added to the "blockNumber" field in this mutation.
func (m *RandomRequestMutation) AddedBlockNumber() (r int64, exists bool) {
	v := m.addblockNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetBlockNumber resets all changes to the "blockNumber" field.
func (m *RandomRequestMutation) ResetBlockNumber() {
	m.blockNumber = nil
	m.addblockNumber = nil
}

// SetLogIndex sets the "logIndex" field.
func (m *RandomRequestMutation) SetLogIndex(u uint) {
	m.logIndex = &u
	m.addlogIndex = nil
}

// LogIndex returns the value of the "logIndex" field in the mutation.
func (m *RandomRequestMutation) LogIndex() (r uint, exists bool) {
	v := m.logIndex
	if v == nil {
		return
	}
	return *v, true
}

// OldLogIndex returns the old "logIndex" field's value of the RandomRequest entity.
// If the RandomRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RandomRequestMutation) OldLogIndex(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogIndex: %w", err)
	}
	return oldValue.LogIndex, nil
}

// AddLogIndex adds u to the "logIndex" field.
func (m *RandomRequestMutation) AddLogIndex(u int) {
	if m.addlogIndex != nil {
		*m.addlogIndex += u
	} else {
		m.addlogIndex = &u
	}
}

// AddedLogIndex returns the value that was added to the "logIndex" field in this mutation.
func (m *RandomRequestMutation) AddedLogIndex() (r int, exists bool) {
	v := m.addlogIndex
	if v == nil {
		return
	}
	return *v, true
}

// ResetLogIndex resets all changes to the "logIndex" field.
func (m *RandomRequestMutation) ResetLogIndex() {
	m.logIndex = nil
	m.addlogIndex = nil
}

// SetRaw sets the "raw" field.
func (m *RandomRequestMutation) SetRaw(s string) {
	m.raw = &s
}

// Raw returns the value of the "raw" field in the mutation.
func (m *RandomRequestMutation) Raw() (r string, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the RandomRequest entity.
// If the RandomRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RandomRequestMutation) OldRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ResetRaw resets all changes to the "raw" field.
func (m *RandomRequestMutation) ResetRaw() {
	m.raw = nil
}

// SetPeriod sets the "period" field.
func (m *RandomRequestMutation) SetPeriod(u uint64) {
	m.period = &u
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *RandomRequestMutation) Period() (r uint64, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the RandomRequest entity.
// If the RandomRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RandomRequestMutation) OldPeriod(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds u to the "period" field.
func (m *RandomRequestMutation) AddPeriod(u int64) {
	if m.addperiod != nil {
		*m.addperiod += u
	} else {
		m.addperiod = &u
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *RandomRequestMutation) AddedPeriod() (r int64, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *RandomRequestMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetPreviousBeacon sets the "previousBeacon" field.
func (m *RandomRequestMutation) SetPreviousBeacon(u uint64) {
	m.previousBeacon = &u
	m.addpreviousBeacon = nil
}

// PreviousBeacon returns the value of the "previousBeacon" field in the mutation.
func (m *RandomRequestMutation) PreviousBeacon() (r uint64, exists bool) {
	v := m.previousBeacon
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousBeacon returns the old "previousBeacon" field's value of the RandomRequest entity.
// If the RandomRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RandomRequestMutation) OldPreviousBeacon(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousBeacon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousBeacon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousBeacon: %w", err)
	}
	return oldValue.PreviousBeacon, nil
}

// AddPreviousBeacon adds u to the "previousBeacon" field.
func (m *RandomRequestMutation) AddPreviousBeacon(u int64) {
	if m.addpreviousBeacon != nil {
		*m.addpreviousBeacon += u
	} else {
		m.addpreviousBeacon = &u
	}
}

// AddedPreviousBeacon returns the value that was added to the "previousBeacon" field in this mutation.
func (m *RandomRequestMutation) AddedPreviousBeacon() (r int64, exists bool) {
	v := m.addpreviousBeacon
	if v == nil {
		return
	}
	return *v, true
}

// ResetPreviousBeacon resets all changes to the "previousBeacon" field.
func (m *RandomRequestMutation) ResetPreviousBeacon() {
	m.previousBeacon = nil
	m.addpreviousBeacon = nil
}

// SetTaskID sets the "task" edge to the Task entity by id.
func (m *RandomRequestMutation) SetTaskID(id int) {
	m.task = &id
}

// ClearTask clears the "task" edge to the Task entity.
func (m *RandomRequestMutation) ClearTask() {
	m.clearedtask = true
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *RandomRequestMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskID returns the "task" edge ID in the mutation.
func (m *RandomRequestMutation) TaskID() (id int, exists bool) {
	if m.task != nil {
		return *m.task, true
	}
	return
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *RandomRequestMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *RandomRequestMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the RandomRequestMutation builder.
func (m *RandomRequestMutation) Where(ps ...predicate.RandomRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RandomRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RandomRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RandomRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RandomRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RandomRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RandomRequest).
func (m *RandomRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RandomRequestMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.blockNumber != nil {
		fields = append(fields, randomrequest.FieldBlockNumber)
	}
	if m.logIndex != nil {
		fields = append(fields, randomrequest.FieldLogIndex)
	}
	if m.raw != nil {
		fields = append(fields, randomrequest.FieldRaw)
	}
	if m.period != nil {
		fields = append(fields, randomrequest.FieldPeriod)
	}
	if m.previousBeacon != nil {
		fields = append(fields, randomrequest.FieldPreviousBeacon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RandomRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case randomrequest.FieldBlockNumber:
		return m.BlockNumber()
	case randomrequest.FieldLogIndex:
		return m.LogIndex()
	case randomrequest.FieldRaw:
		return m.Raw()
	case randomrequest.FieldPeriod:
		return m.Period()
	case randomrequest.FieldPreviousBeacon:
		return m.PreviousBeacon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RandomRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case randomrequest.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case randomrequest.FieldLogIndex:
		return m.OldLogIndex(ctx)
	case randomrequest.FieldRaw:
		return m.OldRaw(ctx)
	case randomrequest.FieldPeriod:
		return m.OldPeriod(ctx)
	case randomrequest.FieldPreviousBeacon:
		return m.OldPreviousBeacon(ctx)
	}
	return nil, fmt.Errorf("unknown RandomRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RandomRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case randomrequest.FieldBlockNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case randomrequest.FieldLogIndex:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogIndex(v)
		return nil
	case randomrequest.FieldRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	case randomrequest.FieldPeriod:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case randomrequest.FieldPreviousBeacon:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousBeacon(v)
		return nil
	}
	return fmt.Errorf("unknown RandomRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RandomRequestMutation) AddedFields() []string {
	var fields []string
	if m.addblockNumber != nil {
		fields = append(fields, randomrequest.FieldBlockNumber)
	}
	if m.addlogIndex != nil {
		fields = append(fields, randomrequest.FieldLogIndex)
	}
	if m.addperiod != nil {
		fields = append(fields, randomrequest.FieldPeriod)
	}
	if m.addpreviousBeacon != nil {
		fields = append(fields, randomrequest.FieldPreviousBeacon)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RandomRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case randomrequest.FieldBlockNumber:
		return m.AddedBlockNumber()
	case randomrequest.FieldLogIndex:
		return m.AddedLogIndex()
	case randomrequest.FieldPeriod:
		return m.AddedPeriod()
	case randomrequest.FieldPreviousBeacon:
		return m.AddedPreviousBeacon()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RandomRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case randomrequest.FieldBlockNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBlockNumber(v)
		return nil
	case randomrequest.FieldLogIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLogIndex(v)
		return nil
	case randomrequest.FieldPeriod:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case randomrequest.FieldPreviousBeacon:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPreviousBeacon(v)
		return nil
	}
	return fmt.Errorf("unknown RandomRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RandomRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RandomRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RandomRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RandomRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RandomRequestMutation) ResetField(name string) error {
	switch name {
	case randomrequest.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case randomrequest.FieldLogIndex:
		m.ResetLogIndex()
		return nil
	case randomrequest.FieldRaw:
		m.ResetRaw()
		return nil
	case randomrequest.FieldPeriod:
		m.ResetPeriod()
		return nil
	case randomrequest.FieldPreviousBeacon:
		m.ResetPreviousBeacon()
		return nil
	}
	return fmt.Errorf("unknown RandomRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RandomRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, randomrequest.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RandomRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case randomrequest.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RandomRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RandomRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RandomRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, randomrequest.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RandomRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case randomrequest.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RandomRequestMutation) ClearEdge(name string) error {
	switch name {
	case randomrequest.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown RandomRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RandomRequestMutation) ResetEdge(name string) error {
	switch name {
	case randomrequest.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown RandomRequest edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	txHash               *string
	data                 *string
	status               *task.Status
	lastError            *string
	reOrg                *bool
	attempts             *int
	addattempts          *int
	lastSent             *int
	addlastSent          *int
	isFinalized          *bool
	sentBlock            *int
	addsentBlock         *int
	createdAt            *int
	addcreatedAt         *int
	clearedFields        map[string]struct{}
	randomrequest        map[string]struct{}
	removedrandomrequest map[string]struct{}
	clearedrandomrequest bool
	done                 bool
	oldValue             func(context.Context) (*Task, error)
	predicates           []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTxHash sets the "txHash" field.
func (m *TaskMutation) SetTxHash(s string) {
	m.txHash = &s
}

// TxHash returns the value of the "txHash" field in the mutation.
func (m *TaskMutation) TxHash() (r string, exists bool) {
	v := m.txHash
	if v == nil {
		return
	}
	return *v, true
}

// OldTxHash returns the old "txHash" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTxHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTxHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTxHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTxHash: %w", err)
	}
	return oldValue.TxHash, nil
}

// ClearTxHash clears the value of the "txHash" field.
func (m *TaskMutation) ClearTxHash() {
	m.txHash = nil
	m.clearedFields[task.FieldTxHash] = struct{}{}
}

// TxHashCleared returns if the "txHash" field was cleared in this mutation.
func (m *TaskMutation) TxHashCleared() bool {
	_, ok := m.clearedFields[task.FieldTxHash]
	return ok
}

// ResetTxHash resets all changes to the "txHash" field.
func (m *TaskMutation) ResetTxHash() {
	m.txHash = nil
	delete(m.clearedFields, task.FieldTxHash)
}

// SetData sets the "data" field.
func (m *TaskMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *TaskMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *TaskMutation) ResetData() {
	m.data = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(t task.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetLastError sets the "lastError" field.
func (m *TaskMutation) SetLastError(s string) {
	m.lastError = &s
}

// LastError returns the value of the "lastError" field in the mutation.
func (m *TaskMutation) LastError() (r string, exists bool) {
	v := m.lastError
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "lastError" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "lastError" field.
func (m *TaskMutation) ClearLastError() {
	m.lastError = nil
	m.clearedFields[task.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "lastError" field was cleared in this mutation.
func (m *TaskMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[task.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "lastError" field.
func (m *TaskMutation) ResetLastError() {
	m.lastError = nil
	delete(m.clearedFields, task.FieldLastError)
}

// SetReOrg sets the "reOrg" field.
func (m *TaskMutation) SetReOrg(b bool) {
	m.reOrg = &b
}

// ReOrg returns the value of the "reOrg" field in the mutation.
func (m *TaskMutation) ReOrg() (r bool, exists bool) {
	v := m.reOrg
	if v == nil {
		return
	}
	return *v, true
}

// OldReOrg returns the old "reOrg" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldReOrg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReOrg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReOrg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReOrg: %w", err)
	}
	return oldValue.ReOrg, nil
}

// ResetReOrg resets all changes to the "reOrg" field.
func (m *TaskMutation) ResetReOrg() {
	m.reOrg = nil
}

// SetAttempts sets the "attempts" field.
func (m *TaskMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *TaskMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *TaskMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *TaskMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *TaskMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
}

// SetLastSent sets the "lastSent" field.
func (m *TaskMutation) SetLastSent(i int) {
	m.lastSent = &i
	m.addlastSent = nil
}

// LastSent returns the value of the "lastSent" field in the mutation.
func (m *TaskMutation) LastSent() (r int, exists bool) {
	v := m.lastSent
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSent returns the old "lastSent" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldLastSent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSent: %w", err)
	}
	return oldValue.LastSent, nil
}

// AddLastSent adds i to the "lastSent" field.
func (m *TaskMutation) AddLastSent(i int) {
	if m.addlastSent != nil {
		*m.addlastSent += i
	} else {
		m.addlastSent = &i
	}
}

// AddedLastSent returns the value that was added to the "lastSent" field in this mutation.
func (m *TaskMutation) AddedLastSent() (r int, exists bool) {
	v := m.addlastSent
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastSent clears the value of the "lastSent" field.
func (m *TaskMutation) ClearLastSent() {
	m.lastSent = nil
	m.addlastSent = nil
	m.clearedFields[task.FieldLastSent] = struct{}{}
}

// LastSentCleared returns if the "lastSent" field was cleared in this mutation.
func (m *TaskMutation) LastSentCleared() bool {
	_, ok := m.clearedFields[task.FieldLastSent]
	return ok
}

// ResetLastSent resets all changes to the "lastSent" field.
func (m *TaskMutation) ResetLastSent() {
	m.lastSent = nil
	m.addlastSent = nil
	delete(m.clearedFields, task.FieldLastSent)
}

// SetIsFinalized sets the "isFinalized" field.
func (m *TaskMutation) SetIsFinalized(b bool) {
	m.isFinalized = &b
}

// IsFinalized returns the value of the "isFinalized" field in the mutation.
func (m *TaskMutation) IsFinalized() (r bool, exists bool) {
	v := m.isFinalized
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinalized returns the old "isFinalized" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldIsFinalized(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFinalized is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFinalized requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinalized: %w", err)
	}
	return oldValue.IsFinalized, nil
}

// ResetIsFinalized resets all changes to the "isFinalized" field.
func (m *TaskMutation) ResetIsFinalized() {
	m.isFinalized = nil
}

// SetSentBlock sets the "sentBlock" field.
func (m *TaskMutation) SetSentBlock(i int) {
	m.sentBlock = &i
	m.addsentBlock = nil
}

// SentBlock returns the value of the "sentBlock" field in the mutation.
func (m *TaskMutation) SentBlock() (r int, exists bool) {
	v := m.sentBlock
	if v == nil {
		return
	}
	return *v, true
}

// OldSentBlock returns the old "sentBlock" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSentBlock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentBlock: %w", err)
	}
	return oldValue.SentBlock, nil
}

// AddSentBlock adds i to the "sentBlock" field.
func (m *TaskMutation) AddSentBlock(i int) {
	if m.addsentBlock != nil {
		*m.addsentBlock += i
	} else {
		m.addsentBlock = &i
	}
}

// AddedSentBlock returns the value that was added to the "sentBlock" field in this mutation.
func (m *TaskMutation) AddedSentBlock() (r int, exists bool) {
	v := m.addsentBlock
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentBlock resets all changes to the "sentBlock" field.
func (m *TaskMutation) ResetSentBlock() {
	m.sentBlock = nil
	m.addsentBlock = nil
}

// SetCreatedAt sets the "createdAt" field.
func (m *TaskMutation) SetCreatedAt(i int) {
	m.createdAt = &i
	m.addcreatedAt = nil
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *TaskMutation) CreatedAt() (r int, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "createdAt" field.
func (m *TaskMutation) AddCreatedAt(i int) {
	if m.addcreatedAt != nil {
		*m.addcreatedAt += i
	} else {
		m.addcreatedAt = &i
	}
}

// AddedCreatedAt returns the value that was added to the "createdAt" field in this mutation.
func (m *TaskMutation) AddedCreatedAt() (r int, exists bool) {
	v := m.addcreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.createdAt = nil
	m.addcreatedAt = nil
}

// AddRandomrequestIDs adds the "randomrequest" edge to the RandomRequest entity by ids.
func (m *TaskMutation) AddRandomrequestIDs(ids ...string) {
	if m.randomrequest == nil {
		m.randomrequest = make(map[string]struct{})
	}
	for i := range ids {
		m.randomrequest[ids[i]] = struct{}{}
	}
}

// ClearRandomrequest clears the "randomrequest" edge to the RandomRequest entity.
func (m *TaskMutation) ClearRandomrequest() {
	m.clearedrandomrequest = true
}

// RandomrequestCleared reports if the "randomrequest" edge to the RandomRequest entity was cleared.
func (m *TaskMutation) RandomrequestCleared() bool {
	return m.clearedrandomrequest
}

// RemoveRandomrequestIDs removes the "randomrequest" edge to the RandomRequest entity by IDs.
func (m *TaskMutation) RemoveRandomrequestIDs(ids ...string) {
	if m.removedrandomrequest == nil {
		m.removedrandomrequest = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.randomrequest, ids[i])
		m.removedrandomrequest[ids[i]] = struct{}{}
	}
}

// RemovedRandomrequest returns the removed IDs of the "randomrequest" edge to the RandomRequest entity.
func (m *TaskMutation) RemovedRandomrequestIDs() (ids []string) {
	for id := range m.removedrandomrequest {
		ids = append(ids, id)
	}
	return
}

// RandomrequestIDs returns the "randomrequest" edge IDs in the mutation.
func (m *TaskMutation) RandomrequestIDs() (ids []string) {
	for id := range m.randomrequest {
		ids = append(ids, id)
	}
	return
}

// ResetRandomrequest resets all changes to the "randomrequest" edge.
func (m *TaskMutation) ResetRandomrequest() {
	m.randomrequest = nil
	m.clearedrandomrequest = false
	m.removedrandomrequest = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.txHash != nil {
		fields = append(fields, task.FieldTxHash)
	}
	if m.data != nil {
		fields = append(fields, task.FieldData)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.lastError != nil {
		fields = append(fields, task.FieldLastError)
	}
	if m.reOrg != nil {
		fields = append(fields, task.FieldReOrg)
	}
	if m.attempts != nil {
		fields = append(fields, task.FieldAttempts)
	}
	if m.lastSent != nil {
		fields = append(fields, task.FieldLastSent)
	}
	if m.isFinalized != nil {
		fields = append(fields, task.FieldIsFinalized)
	}
	if m.sentBlock != nil {
		fields = append(fields, task.FieldSentBlock)
	}
	if m.createdAt != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTxHash:
		return m.TxHash()
	case task.FieldData:
		return m.Data()
	case task.FieldStatus:
		return m.Status()
	case task.FieldLastError:
		return m.LastError()
	case task.FieldReOrg:
		return m.ReOrg()
	case task.FieldAttempts:
		return m.Attempts()
	case task.FieldLastSent:
		return m.LastSent()
	case task.FieldIsFinalized:
		return m.IsFinalized()
	case task.FieldSentBlock:
		return m.SentBlock()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldTxHash:
		return m.OldTxHash(ctx)
	case task.FieldData:
		return m.OldData(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldLastError:
		return m.OldLastError(ctx)
	case task.FieldReOrg:
		return m.OldReOrg(ctx)
	case task.FieldAttempts:
		return m.OldAttempts(ctx)
	case task.FieldLastSent:
		return m.OldLastSent(ctx)
	case task.FieldIsFinalized:
		return m.OldIsFinalized(ctx)
	case task.FieldSentBlock:
		return m.OldSentBlock(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldTxHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTxHash(v)
		return nil
	case task.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case task.FieldReOrg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReOrg(v)
		return nil
	case task.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case task.FieldLastSent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSent(v)
		return nil
	case task.FieldIsFinalized:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinalized(v)
		return nil
	case task.FieldSentBlock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentBlock(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, task.FieldAttempts)
	}
	if m.addlastSent != nil {
		fields = append(fields, task.FieldLastSent)
	}
	if m.addsentBlock != nil {
		fields = append(fields, task.FieldSentBlock)
	}
	if m.addcreatedAt != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldAttempts:
		return m.AddedAttempts()
	case task.FieldLastSent:
		return m.AddedLastSent()
	case task.FieldSentBlock:
		return m.AddedSentBlock()
	case task.FieldCreatedAt:
		return m.AddedCreatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	case task.FieldLastSent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastSent(v)
		return nil
	case task.FieldSentBlock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentBlock(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldTxHash) {
		fields = append(fields, task.FieldTxHash)
	}
	if m.FieldCleared(task.FieldLastError) {
		fields = append(fields, task.FieldLastError)
	}
	if m.FieldCleared(task.FieldLastSent) {
		fields = append(fields, task.FieldLastSent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldTxHash:
		m.ClearTxHash()
		return nil
	case task.FieldLastError:
		m.ClearLastError()
		return nil
	case task.FieldLastSent:
		m.ClearLastSent()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldTxHash:
		m.ResetTxHash()
		return nil
	case task.FieldData:
		m.ResetData()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldLastError:
		m.ResetLastError()
		return nil
	case task.FieldReOrg:
		m.ResetReOrg()
		return nil
	case task.FieldAttempts:
		m.ResetAttempts()
		return nil
	case task.FieldLastSent:
		m.ResetLastSent()
		return nil
	case task.FieldIsFinalized:
		m.ResetIsFinalized()
		return nil
	case task.FieldSentBlock:
		m.ResetSentBlock()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.randomrequest != nil {
		edges = append(edges, task.EdgeRandomrequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeRandomrequest:
		ids := make([]ent.Value, 0, len(m.randomrequest))
		for id := range m.randomrequest {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrandomrequest != nil {
		edges = append(edges, task.EdgeRandomrequest)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeRandomrequest:
		ids := make([]ent.Value, 0, len(m.removedrandomrequest))
		for id := range m.removedrandomrequest {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrandomrequest {
		edges = append(edges, task.EdgeRandomrequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeRandomrequest:
		return m.clearedrandomrequest
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeRandomrequest:
		m.ResetRandomrequest()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}
